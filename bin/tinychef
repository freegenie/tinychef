#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__) + '/../lib')

require 'optparse'
require 'tinychef'

parser = OptionParser.new do |opts|
  opts.banner = "Usage: tinychef COMMAND [ARGS]"

  opts.separator ""
  opts.separator "Options:"

  opts.on("-h", "--help", "Show this message") do
    puts opts
    exit
  end

  opts.separator ""
  opts.separator "Commands:"
  opts.separator "  new DIR                   Creates a new tinychef directory" 
  opts.separator "  boot HOST                 Prepares chef-able environment on HOST"
  opts.separator "  bag:create NAME           Creates an empty databag" 
  opts.separator "  bag:encrypt NAME          Encrypts a databag" 
  opts.separator "  bag:decrypt NAME          Decrypts a databag" 
  opts.separator "  key:lock                  Lock the key with a password"
  opts.separator "  key:unlock                Unlock the key for a work session" 
  opts.separator "  secure                    Remove all unsecure files from this folder" 
  opts.separator "  unsecure                  Unlock key and decrypt all data bags" 
  opts.separator "  run HOST NODE [RUN_LIST]  Runs recipes for NODE on HOST with optional run_list"
  opts.separator ""

end

parser.parse!

begin
  case ARGV[0]
  when 'new'
    Tinychef::NewDirectory.new(ARGV[1]).create
  when 'boot'
  when 'bag:create'
  when 'bag:encrypt'
  when 'bag:decrypt'
  when 'key:lock'
  when 'key:unlock'
  when 'secure'
  when 'unsecure'
  when 'run'
    options = {}

    options[:node] = ARGV[1]

    if ARGV.size == 3 # assume the destination is not given
      options[:dest] = nil ; options[:run_list] = ARGV[2]
    else
      options[:dest] = ARGV[2] ; options[:run_list] = ARGV[3]
    end

    Tinychef::NodeRun.new(options).start
  else
    puts parser.help
  end
rescue Tinychef::NodeRun::OptionsError => e
  abort e.message


end
